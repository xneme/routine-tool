---
phase: 02-organization-focus
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - app/src/main/java/com/routinetool/ui/screens/focus/FocusViewModel.kt
  - app/src/main/java/com/routinetool/ui/screens/focus/FocusViewScreen.kt
  - app/src/main/java/com/routinetool/ui/navigation/NavRoutes.kt
  - app/src/main/java/com/routinetool/ui/navigation/AppNavHost.kt
  - app/src/main/java/com/routinetool/di/AppModule.kt
autonomous: true

must_haves:
  truths:
    - "User can access focus view from FAB menu"
    - "Focus view shows limited number of priority tasks"
    - "User can adjust task limit in focus view"
    - "User can pin/unpin tasks in focus view"
    - "Focus config (limit and pinned tasks) persists across app restarts"
    - "Focus view can be dismissed by back navigation"
  artifacts:
    - path: "app/src/main/java/com/routinetool/ui/screens/focus/FocusViewModel.kt"
      provides: "Focus view state management with task selection algorithm"
      exports: ["FocusViewModel", "FocusUiState"]
    - path: "app/src/main/java/com/routinetool/ui/screens/focus/FocusViewScreen.kt"
      provides: "Full-screen focus view composable"
      min_lines: 100
  key_links:
    - from: "FocusViewModel"
      to: "TaskRepository"
      via: "Koin injection"
      pattern: "FocusViewModel.*TaskRepository"
    - from: "FocusViewModel"
      to: "PreferencesDataStore"
      via: "Koin injection"
      pattern: "FocusViewModel.*PreferencesDataStore"
    - from: "AppNavHost"
      to: "FocusViewScreen"
      via: "Navigation composable"
      pattern: "composable.*FOCUS_VIEW.*FocusViewScreen"
---

<objective>
Create Focus View feature with curated task list to combat overwhelm.

Purpose: Success criteria 3 (access focus view with limited priority tasks) and 4 (adjust task limit) - provides neurodivergent users a distraction-free view of their most important tasks.

Output: FocusViewScreen composable, FocusViewModel with hybrid task selection (algorithm + user pins), navigation integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-organization-focus/02-CONTEXT.md
@.planning/phases/02-organization-focus/02-RESEARCH.md
@.planning/phases/02-organization-focus/02-01-SUMMARY.md

@app/src/main/java/com/routinetool/data/preferences/PreferencesDataStore.kt
@app/src/main/java/com/routinetool/data/repository/TaskRepository.kt
@app/src/main/java/com/routinetool/domain/model/Task.kt
@app/src/main/java/com/routinetool/ui/navigation/NavRoutes.kt
@app/src/main/java/com/routinetool/ui/navigation/AppNavHost.kt
@app/src/main/java/com/routinetool/ui/components/TaskCard.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FocusViewModel with task selection algorithm</name>
  <files>
    app/src/main/java/com/routinetool/ui/screens/focus/FocusViewModel.kt
    app/src/main/java/com/routinetool/di/AppModule.kt
  </files>
  <action>
1. Create new package: `com.routinetool.ui.screens.focus`

2. Create FocusViewModel.kt:
```kotlin
package com.routinetool.ui.screens.focus

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.routinetool.data.preferences.PreferencesDataStore
import com.routinetool.data.repository.TaskRepository
import com.routinetool.domain.model.Task
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import kotlinx.datetime.Instant

class FocusViewModel(
    private val repository: TaskRepository,
    private val preferencesDataStore: PreferencesDataStore
) : ViewModel() {

    private val taskLimit = preferencesDataStore.focusTaskLimit
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), 5)

    private val pinnedTaskIds = preferencesDataStore.focusPinnedTaskIds
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptySet())

    val uiState: StateFlow<FocusUiState> = combine(
        repository.observeActiveTasks(),
        taskLimit,
        pinnedTaskIds
    ) { activeTasks, limit, pinned ->
        val focusTasks = selectFocusTasks(activeTasks, limit, pinned)
        FocusUiState(
            focusTasks = focusTasks,
            taskLimit = limit,
            pinnedTaskIds = pinned,
            isLoading = false
        )
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = FocusUiState(isLoading = true)
    )

    /**
     * Hybrid task selection algorithm.
     * Pinned tasks always appear first, remaining slots filled by urgency.
     */
    private fun selectFocusTasks(
        allTasks: List<Task>,
        limit: Int,
        pinnedIds: Set<String>
    ): List<Task> {
        // Get pinned tasks that still exist and are active
        val pinnedTasks = allTasks.filter { it.id in pinnedIds }
        val remainingSlots = (limit - pinnedTasks.size).coerceAtLeast(0)

        // Fill remaining slots with non-pinned tasks by urgency
        val autoSelected = if (remainingSlots > 0) {
            allTasks
                .filterNot { it.id in pinnedIds }
                .sortedWith(urgencyComparator())
                .take(remainingSlots)
        } else {
            emptyList()
        }

        // Pinned first, then auto-selected
        return (pinnedTasks + autoSelected).take(limit)
    }

    /**
     * Urgency comparator: overdue first, then nearest deadline, then no deadline.
     */
    private fun urgencyComparator(): Comparator<Task> {
        val now = System.currentTimeMillis()
        return compareBy(
            { task ->
                val deadline = listOfNotNull(task.softDeadline, task.hardDeadline).minOrNull()
                if (deadline != null && deadline.toEpochMilliseconds() < now) 0 else 1
            },
            { task ->
                listOfNotNull(task.softDeadline, task.hardDeadline).minOrNull()?.toEpochMilliseconds() ?: Long.MAX_VALUE
            }
        )
    }

    fun togglePin(taskId: String) {
        viewModelScope.launch {
            val current = pinnedTaskIds.value
            val updated = if (taskId in current) current - taskId else current + taskId
            preferencesDataStore.saveFocusPinnedTaskIds(updated)
        }
    }

    fun setTaskLimit(limit: Int) {
        viewModelScope.launch {
            preferencesDataStore.saveFocusTaskLimit(limit.coerceIn(1, 10))
        }
    }

    fun completeTask(taskId: String) {
        viewModelScope.launch {
            repository.completeTask(taskId)
        }
    }
}

data class FocusUiState(
    val focusTasks: List<Task> = emptyList(),
    val taskLimit: Int = 5,
    val pinnedTaskIds: Set<String> = emptySet(),
    val isLoading: Boolean = true
)
```

3. Update AppModule.kt to register FocusViewModel:
```kotlin
viewModel { FocusViewModel(get(), get()) }
```
  </action>
  <verify>
Build with `./gradlew :app:compileDebugKotlin`. No compilation errors.
  </verify>
  <done>
FocusViewModel implements hybrid task selection (pinned + auto-selected by urgency) with persistent configuration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FocusViewScreen composable</name>
  <files>
    app/src/main/java/com/routinetool/ui/screens/focus/FocusViewScreen.kt
  </files>
  <action>
Create FocusViewScreen.kt:
```kotlin
package com.routinetool.ui.screens.focus

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.PushPin
import androidx.compose.material.icons.outlined.PushPin
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.routinetool.domain.model.Task
import org.koin.androidx.compose.koinViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun FocusViewScreen(
    onBack: () -> Unit,
    viewModel: FocusViewModel = koinViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Focus") },
                navigationIcon = {
                    IconButton(onClick = onBack) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back")
                    }
                },
                actions = {
                    // Task limit selector
                    TaskLimitSelector(
                        currentLimit = uiState.taskLimit,
                        onLimitChange = { viewModel.setTaskLimit(it) }
                    )
                }
            )
        }
    ) { paddingValues ->
        if (uiState.isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else if (uiState.focusTasks.isEmpty()) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = "No tasks to focus on",
                    style = MaterialTheme.typography.bodyLarge,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        } else {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                items(uiState.focusTasks, key = { it.id }) { task ->
                    FocusTaskCard(
                        task = task,
                        isPinned = task.id in uiState.pinnedTaskIds,
                        onTogglePin = { viewModel.togglePin(task.id) },
                        onComplete = { viewModel.completeTask(task.id) }
                    )
                }
            }
        }
    }
}

@Composable
private fun TaskLimitSelector(
    currentLimit: Int,
    onLimitChange: (Int) -> Unit
) {
    var expanded by remember { mutableStateOf(false) }

    Box {
        TextButton(onClick = { expanded = true }) {
            Text("$currentLimit tasks")
        }
        DropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false }
        ) {
            (1..10).forEach { limit ->
                DropdownMenuItem(
                    text = { Text("$limit task${if (limit > 1) "s" else ""}") },
                    onClick = {
                        onLimitChange(limit)
                        expanded = false
                    },
                    leadingIcon = if (currentLimit == limit) {
                        { Icon(Icons.Default.Check, null) }
                    } else null
                )
            }
        }
    }
}

@Composable
private fun FocusTaskCard(
    task: Task,
    isPinned: Boolean,
    onTogglePin: () -> Unit,
    onComplete: () -> Unit
) {
    ElevatedCard(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.elevatedCardElevation(defaultElevation = 4.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = task.title,
                    style = MaterialTheme.typography.titleMedium
                )
                if (!task.description.isNullOrBlank()) {
                    Text(
                        text = task.description,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant,
                        maxLines = 2
                    )
                }
                // Show deadline if exists
                val deadline = listOfNotNull(task.softDeadline, task.hardDeadline).minOrNull()
                if (deadline != null) {
                    val isOverdue = deadline.toEpochMilliseconds() < System.currentTimeMillis()
                    Text(
                        text = if (isOverdue) "Overdue" else "Due: ${formatDeadline(deadline)}",
                        style = MaterialTheme.typography.labelSmall,
                        color = if (isOverdue) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }

            Row {
                // Pin toggle
                IconButton(onClick = onTogglePin) {
                    Icon(
                        imageVector = if (isPinned) Icons.Filled.PushPin else Icons.Outlined.PushPin,
                        contentDescription = if (isPinned) "Unpin" else "Pin",
                        tint = if (isPinned) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
                // Complete button
                IconButton(onClick = onComplete) {
                    Icon(
                        imageVector = Icons.Default.Check,
                        contentDescription = "Complete",
                        tint = MaterialTheme.colorScheme.primary
                    )
                }
            }
        }
    }
}

private fun formatDeadline(deadline: kotlinx.datetime.Instant): String {
    val date = deadline.toLocalDateTime(kotlinx.datetime.TimeZone.currentSystemDefault()).date
    return date.toString()
}
```

Add missing import at top: `import androidx.compose.material.icons.filled.Check`
  </action>
  <verify>
Build with `./gradlew :app:compileDebugKotlin`. No compilation errors.
  </verify>
  <done>
FocusViewScreen displays limited priority tasks with pin toggles and task limit selector.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add navigation route and wire up AppNavHost</name>
  <files>
    app/src/main/java/com/routinetool/ui/navigation/NavRoutes.kt
    app/src/main/java/com/routinetool/ui/navigation/AppNavHost.kt
  </files>
  <action>
1. Update NavRoutes.kt:
```kotlin
package com.routinetool.ui.navigation

object NavRoutes {
    const val TASK_LIST = "task_list"
    const val ADD_TASK = "add_task"
    const val EDIT_TASK = "edit_task/{taskId}"
    const val FOCUS_VIEW = "focus_view"

    fun editTask(taskId: String) = "edit_task/$taskId"
}
```

2. Update AppNavHost.kt to add Focus View route:
```kotlin
package com.routinetool.ui.navigation

import androidx.compose.runtime.Composable
import androidx.navigation.NavHostController
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import androidx.navigation.navArgument
import com.routinetool.ui.screens.addtask.AddTaskScreen
import com.routinetool.ui.screens.focus.FocusViewScreen
import com.routinetool.ui.screens.tasklist.TaskListScreen

@Composable
fun AppNavHost(
    navController: NavHostController = rememberNavController()
) {
    NavHost(
        navController = navController,
        startDestination = NavRoutes.TASK_LIST
    ) {
        composable(NavRoutes.TASK_LIST) {
            TaskListScreen(
                onAddTask = { navController.navigate(NavRoutes.ADD_TASK) },
                onEditTask = { taskId -> navController.navigate(NavRoutes.editTask(taskId)) },
                onNavigateToFocus = { navController.navigate(NavRoutes.FOCUS_VIEW) }
            )
        }

        composable(NavRoutes.ADD_TASK) {
            AddTaskScreen(
                onNavigateBack = { navController.popBackStack() }
            )
        }

        composable(
            route = NavRoutes.EDIT_TASK,
            arguments = listOf(navArgument("taskId") { type = NavType.StringType })
        ) { backStackEntry ->
            val taskId = backStackEntry.arguments?.getString("taskId")
            AddTaskScreen(
                onNavigateBack = { navController.popBackStack() },
                taskId = taskId
            )
        }

        composable(NavRoutes.FOCUS_VIEW) {
            FocusViewScreen(
                onBack = { navController.popBackStack() }
            )
        }
    }
}
```

3. Update TaskListScreen signature to accept onNavigateToFocus callback and modify FAB to be a FAB menu:

In TaskListScreen.kt, add parameter and update FAB:
```kotlin
@Composable
fun TaskListScreen(
    onAddTask: () -> Unit,
    onEditTask: (String) -> Unit = {},
    onNavigateToFocus: () -> Unit = {},  // NEW
    viewModel: TaskListViewModel = koinViewModel()
) {
    // ... existing code ...

    // Replace simple FAB with expandable FAB menu
    var fabExpanded by remember { mutableStateOf(false) }

    Scaffold(
        floatingActionButton = {
            Column(
                horizontalAlignment = Alignment.End,
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                // Secondary actions (shown when expanded)
                AnimatedVisibility(visible = fabExpanded) {
                    SmallFloatingActionButton(
                        onClick = {
                            fabExpanded = false
                            onNavigateToFocus()
                        },
                        containerColor = MaterialTheme.colorScheme.secondaryContainer
                    ) {
                        Icon(Icons.Default.CenterFocusStrong, "Focus")
                    }
                }
                // Main FAB
                FloatingActionButton(
                    onClick = {
                        if (fabExpanded) {
                            fabExpanded = false
                            onAddTask()
                        } else {
                            fabExpanded = !fabExpanded
                        }
                    }
                ) {
                    Icon(
                        imageVector = if (fabExpanded) Icons.Filled.Add else Icons.Filled.MoreVert,
                        contentDescription = if (fabExpanded) "Add task" else "Show options"
                    )
                }
            }
        }
    ) { ... }
}
```

Add imports for AnimatedVisibility, SmallFloatingActionButton, CenterFocusStrong, MoreVert, etc.
  </action>
  <verify>
Build and run app. Verify:
1. FAB shows options menu when tapped
2. Focus option navigates to Focus View
3. Add option navigates to Add Task
4. Back from Focus View returns to Task List
  </verify>
  <done>
Focus View is accessible via FAB menu and properly integrated into navigation.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build: `./gradlew :app:assembleDebug` succeeds
2. Run app and verify:
   - FAB expands to show Focus option
   - Tapping Focus navigates to Focus View screen
   - Focus View shows limited tasks (default 5)
   - Task limit dropdown allows 1-10 selection
   - Changing limit persists after app restart
   - Pin icon toggles on tasks
   - Pinned tasks always appear first
   - Completing a task removes it from focus
   - Back button returns to Task List
</verification>

<success_criteria>
- Focus View accessible from FAB menu
- Displays limited number of priority tasks (default 5)
- Task limit is user-configurable (1-10)
- Configuration persists across app restarts
- Pin/unpin functionality works
- Pinned tasks prioritized over auto-selected
- Task completion works from Focus View
- Navigation back to Task List works
</success_criteria>

<output>
After completion, create `.planning/phases/02-organization-focus/02-03-SUMMARY.md`
</output>

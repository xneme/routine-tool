---
phase: 02-organization-focus
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - app/src/main/java/com/routinetool/ui/screens/tasklist/TaskListViewModel.kt
  - app/src/main/java/com/routinetool/ui/screens/tasklist/TaskListScreen.kt
autonomous: true

must_haves:
  truths:
    - "User can change sort order via dropdown menu"
    - "Sort preference persists after app restart"
    - "User can toggle filters via filter chips"
    - "Filter chips reset to all-selected when app restarts"
    - "Filtered tasks update immediately when filter changes"
    - "Sorted tasks update immediately when sort changes"
  artifacts:
    - path: "app/src/main/java/com/routinetool/ui/screens/tasklist/TaskListViewModel.kt"
      provides: "ViewModel with sort/filter state management via StateFlow combine"
      exports: ["TaskListViewModel", "TaskListUiState"]
    - path: "app/src/main/java/com/routinetool/ui/screens/tasklist/TaskListScreen.kt"
      provides: "Task list with sort dropdown and filter chips"
      min_lines: 250
  key_links:
    - from: "TaskListViewModel"
      to: "PreferencesDataStore"
      via: "Koin injection"
      pattern: "TaskListViewModel.*PreferencesDataStore"
    - from: "TaskListScreen"
      to: "SortDropdown"
      via: "DropdownMenu composable"
      pattern: "DropdownMenu.*expanded"
    - from: "TaskListScreen"
      to: "FilterChips"
      via: "LazyRow with FilterChip"
      pattern: "FilterChip.*selected"
---

<objective>
Implement sorting and filtering UI in the task list screen with persistent sort preference.

Purpose: Success criteria 1 (sort by urgency/deadline/creation) and 2 (filter task list) - enables users to organize their view to reduce overwhelm.

Output: Sort dropdown menu, horizontal filter chip row, ViewModel with reactive filter/sort logic.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-organization-focus/02-CONTEXT.md
@.planning/phases/02-organization-focus/02-RESEARCH.md
@.planning/phases/02-organization-focus/02-01-SUMMARY.md

@app/src/main/java/com/routinetool/ui/screens/tasklist/TaskListViewModel.kt
@app/src/main/java/com/routinetool/ui/screens/tasklist/TaskListScreen.kt
@app/src/main/java/com/routinetool/data/preferences/PreferencesDataStore.kt
@app/src/main/java/com/routinetool/domain/model/SortOption.kt
@app/src/main/java/com/routinetool/domain/model/FilterState.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update TaskListViewModel with sort/filter logic</name>
  <files>
    app/src/main/java/com/routinetool/ui/screens/tasklist/TaskListViewModel.kt
    app/src/main/java/com/routinetool/di/AppModule.kt
  </files>
  <action>
1. Update AppModule.kt to inject PreferencesDataStore into TaskListViewModel:
```kotlin
viewModel { TaskListViewModel(get(), get()) }
```

2. Refactor TaskListViewModel to:
   - Add PreferencesDataStore as constructor parameter
   - Add private `_filterState: MutableStateFlow<FilterState>` with default FilterState()
   - Expose `filterState: StateFlow<FilterState>` as read-only
   - Add `sortOption: StateFlow<SortOption>` from dataStore.sortPreference
   - Add `updateFilter(update: FilterState.() -> FilterState)` function
   - Add `setSortOption(option: SortOption)` function
   - Modify `uiState` to combine repository flows + filterState + sortOption
   - Apply filtering logic: task passes if matches status AND deadline type filters
   - Apply sorting using `SortOption.comparator()`

Key implementation details:
- Filter logic: Task matches if (status matches) AND (deadline type matches)
- Status: showActive matches incomplete non-overdue, showOverdue matches incomplete overdue, showDone matches completed
- Deadline type: showSoftDeadline matches if softDeadline != null, showHardDeadline matches if hardDeadline != null, showNoDeadline matches if both are null
- Sort is applied AFTER filter
- Use `stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), default)` for all StateFlows

TaskListUiState changes:
- Add `currentSort: SortOption = SortOption.URGENCY`
- Keep sections (overdue, active, done) but apply filters to each

Per CONTEXT.md: Filter state does NOT persist. Sort DOES persist via DataStore.
  </action>
  <verify>
Build with `./gradlew :app:compileDebugKotlin`. No compilation errors.
  </verify>
  <done>
TaskListViewModel manages sort/filter state, combines with repository data, and exposes filtered/sorted task lists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Sort Dropdown and Filter Chips to TaskListScreen</name>
  <files>
    app/src/main/java/com/routinetool/ui/screens/tasklist/TaskListScreen.kt
  </files>
  <action>
Add sort dropdown and filter chips to TaskListScreen. Per CONTEXT.md: sort dropdown triggered by icon, filter chips in horizontal scrollable row below.

1. Add imports for DropdownMenu, FilterChip, LazyRow, etc.

2. Create SortDropdown composable:
```kotlin
@Composable
private fun SortDropdown(
    currentSort: SortOption,
    onSortChange: (SortOption) -> Unit,
    modifier: Modifier = Modifier
) {
    var expanded by remember { mutableStateOf(false) }

    Box(modifier = modifier) {
        IconButton(onClick = { expanded = true }) {
            Icon(Icons.Default.Sort, "Sort options")
        }
        DropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false }
        ) {
            SortOption.entries.forEach { option ->
                DropdownMenuItem(
                    text = { Text(option.displayName) },
                    onClick = {
                        onSortChange(option)
                        expanded = false
                    },
                    leadingIcon = if (currentSort == option) {
                        { Icon(Icons.Filled.Check, null) }
                    } else null
                )
            }
        }
    }
}
```

3. Create FilterChipRow composable:
```kotlin
@Composable
private fun FilterChipRow(
    filterState: FilterState,
    onFilterChange: (FilterState) -> Unit,
    modifier: Modifier = Modifier
) {
    LazyRow(
        modifier = modifier,
        contentPadding = PaddingValues(horizontal = 16.dp),
        horizontalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        // Status filters
        item {
            FilterChip(
                selected = filterState.showActive,
                onClick = { onFilterChange(filterState.copy(showActive = !filterState.showActive)) },
                label = { Text("Active") },
                leadingIcon = if (filterState.showActive) {
                    { Icon(Icons.Filled.Done, null, Modifier.size(FilterChipDefaults.IconSize)) }
                } else null
            )
        }
        item {
            FilterChip(
                selected = filterState.showOverdue,
                onClick = { onFilterChange(filterState.copy(showOverdue = !filterState.showOverdue)) },
                label = { Text("Overdue") },
                leadingIcon = if (filterState.showOverdue) {
                    { Icon(Icons.Filled.Done, null, Modifier.size(FilterChipDefaults.IconSize)) }
                } else null
            )
        }
        item {
            FilterChip(
                selected = filterState.showDone,
                onClick = { onFilterChange(filterState.copy(showDone = !filterState.showDone)) },
                label = { Text("Done") },
                leadingIcon = if (filterState.showDone) {
                    { Icon(Icons.Filled.Done, null, Modifier.size(FilterChipDefaults.IconSize)) }
                } else null
            )
        }
        // Deadline type filters
        item {
            FilterChip(
                selected = filterState.showSoftDeadline,
                onClick = { onFilterChange(filterState.copy(showSoftDeadline = !filterState.showSoftDeadline)) },
                label = { Text("Soft") },
                leadingIcon = if (filterState.showSoftDeadline) {
                    { Icon(Icons.Filled.Done, null, Modifier.size(FilterChipDefaults.IconSize)) }
                } else null
            )
        }
        item {
            FilterChip(
                selected = filterState.showHardDeadline,
                onClick = { onFilterChange(filterState.copy(showHardDeadline = !filterState.showHardDeadline)) },
                label = { Text("Hard") },
                leadingIcon = if (filterState.showHardDeadline) {
                    { Icon(Icons.Filled.Done, null, Modifier.size(FilterChipDefaults.IconSize)) }
                } else null
            )
        }
        item {
            FilterChip(
                selected = filterState.showNoDeadline,
                onClick = { onFilterChange(filterState.copy(showNoDeadline = !filterState.showNoDeadline)) },
                label = { Text("No deadline") },
                leadingIcon = if (filterState.showNoDeadline) {
                    { Icon(Icons.Filled.Done, null, Modifier.size(FilterChipDefaults.IconSize)) }
                } else null
            )
        }
    }
}
```

4. Update TaskListScreen composable:
   - Collect filterState and uiState from viewModel
   - Add Row at top with sort dropdown (aligned end)
   - Add FilterChipRow below the sort row
   - Wire dropdown to viewModel.setSortOption
   - Wire filter chips to viewModel.updateFilter
   - Use Spacer or padding between controls and list

Layout:
```
[             Sort icon ▼]
[Active] [Overdue] [Done] [Soft] [Hard] [No deadline]
───────────────────────────────────────────────────────
Overdue section...
Tasks section...
Done section...
```
  </action>
  <verify>
Build and run app. Verify:
1. Sort dropdown appears with 3 options
2. Selecting sort option updates task order
3. Filter chips appear horizontally
4. Toggling filter chip updates visible tasks
5. Sort persists after app restart
6. Filters reset to all-selected after app restart
  </verify>
  <done>
TaskListScreen has sort dropdown and filter chip row that control task list display. Sort persists, filters do not.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build: `./gradlew :app:assembleDebug` succeeds
2. Run app and verify:
   - Sort dropdown shows 3 options (Urgency, Deadline, Created)
   - Current sort shows check mark
   - Filter chips all selected by default
   - Deselecting "Active" hides active tasks
   - Deselecting "Overdue" hides overdue tasks
   - Deselecting "Done" hides done tasks
   - Deadline type filters work (Soft/Hard/No deadline)
   - Sort by Deadline: tasks ordered by nearest deadline
   - Sort by Created: newest tasks first
   - Restart app: sort preference preserved, filters reset to all-on
</verification>

<success_criteria>
- Sort dropdown appears and allows selection
- Selected sort option persists across app restarts
- Filter chips appear in horizontal scrollable row
- Filter state resets to all-selected on app restart
- Task list updates reactively when sort/filter changes
- All 6 filter dimensions work correctly (3 status + 3 deadline type)
- UI is responsive and doesn't block main thread
</success_criteria>

<output>
After completion, create `.planning/phases/02-organization-focus/02-02-SUMMARY.md`
</output>
